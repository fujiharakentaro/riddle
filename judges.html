<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Card Master V23 (Smart Mat)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/js-aruco@0.0.1/src/cv.js"></script>
    <script src="https://unpkg.com/js-aruco@0.0.1/src/aruco.js"></script>

    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; background: #000; color: #fff; margin: 0; overflow: hidden; width: 100vw; height: 100dvh; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        #canvas-container {
            position: relative; width: 100%; max-width: 640px; 
            background: #222; box-shadow: 0 0 20px rgba(0,255,0,0.2);
            display: flex; justify-content: center; align-items: center; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: auto; }
        
        /* å†…éƒ¨å‡¦ç†ç”¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã¯éš ã™ */
        #proc-canvas { display: none; }

        .game-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10;
        }
        
        button, .btn-float, .judge-btn { cursor: pointer; pointer-events: auto; }

        .btn-float { 
            background: rgba(0,0,0,0.6); color: #fff; border: 1px solid #fff; 
            padding: 8px 15px; border-radius: 20px; font-size: 12px; margin: 10px; 
        }
        .btn-float:hover { background: rgba(255,255,255,0.2); }

        .judge-btn { 
            width: 80%; padding: 15px; font-size: 1.5rem; font-weight: bold; border: none; border-radius: 50px; 
            color: white; background: linear-gradient(to bottom, #28a745, #208030); 
            align-self: center; margin-bottom: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        #title-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #title-content {
            width: 90%; max-width: 500px; height: 80%; overflow-y: auto; text-align: center;
        }

        #controls { width: 90%; max-width: 600px; background: #222; padding: 10px; border-radius: 10px; margin-top: 10px; z-index: 5; }
        .slider-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: grab; }

        #settings-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #151515; z-index: 200; transform: translateY(100%); 
            transition: transform 0.3s; padding: 20px; overflow-y: auto; box-sizing: border-box; 
        }
        #settings-overlay.open { transform: translateY(0); }
        .setting-box { background: #252525; padding: 15px; border-radius: 12px; margin-bottom: 20px; border: 1px solid #444; }
        h3 { margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 5px; font-size:1rem; color:#ddd; }

        .card-list { display: flex; overflow-x: auto; gap: 10px; padding: 10px 0; min-height: 80px;}
        .card-thumb { 
            min-width: 60px; height: 80px; background: #000; border: 1px solid #555; border-radius:4px;
            display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative;
        }
        .card-thumb img { width: 100%; height: 100%; object-fit: contain; }
        
        input[type="text"], select { 
            padding: 10px; width: 100%; margin-bottom: 5px; box-sizing: border-box; 
            background: #333; color: #fff; border: 1px solid #555; border-radius: 5px; 
        }

        .level-row {
            background: #333; padding: 10px; margin-bottom: 5px; border-radius: 6px; border: 1px solid #444;
            display: flex; flex-direction: column; cursor: default;
        }
        .level-row-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .btn-mini { padding: 4px 8px; font-size: 11px; border-radius: 4px; border: none; margin-left: 5px; color: #fff;}
        .btn-edit { background: #007bff; } .btn-del { background: #dc3545; }

        #result-view { 
            position: fixed; top:0; left:0; width:100%; height:100%; 
            background: rgba(0,0,0,0.9); display: none; z-index: 400; 
            flex-direction: column; justify-content: center; align-items: center; cursor: pointer;
        }
        #status-msg { 
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%); 
            background: rgba(40,167,69,0.95); padding: 8px 20px; border-radius: 20px; 
            font-size:12px; opacity:0; transition:opacity 0.5s; z-index:300; pointer-events: none;
        }
        #ar-guide-msg {
            position: absolute; top:50%; left:50%; transform:translate(-50%, -50%);
            color: #ff0; font-weight: bold; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px;
            pointer-events: none; text-align: center; display: none;
        }
        
        video { display: none; }
    </style>
</head>
<body>

<div id="title-screen">
    <div id="title-content">
        <h1 style="text-shadow:0 0 10px #000; margin-bottom:10px;">CARD MASTER</h1>
        <p style="font-size:12px; color:#ccc; margin-bottom:20px;">å•é¡Œã‚’é¸æŠã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</p>
        <div id="title-level-list"></div>
        <div style="margin-top:30px;">
            <button class="btn-float" onclick="openSettings()">âš™ï¸ è¨­å®šãƒ»ã‚«ãƒ¼ãƒ‰ç™»éŒ²</button>
        </div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="main-canvas"></canvas>
    <canvas id="proc-canvas"></canvas>
    
    <div id="ar-guide-msg">å››éš…ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’<br>ã™ã¹ã¦æ˜ ã—ã¦ãã ã•ã„</div>

    <div class="game-ui" id="game-ui" style="display:none;">
        <div style="display:flex; justify-content:space-between;">
            <button class="btn-float" onclick="startCam(true)">ğŸ“· å†èµ·å‹•</button>
            <button class="btn-float" onclick="goTitle()">ğŸ  ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>
        </div>
        <div style="position:absolute; bottom:80px; left:10px;">
            <button class="btn-float" onclick="toggleViewMode()">ğŸ¨ è¡¨ç¤ºåˆ‡æ›¿</button>
        </div>
        <button id="btn-judge" class="judge-btn" onclick="judge()">åˆ¤ å®š !</button>
    </div>
</div>

<div id="controls">
    <div class="slider-row">
        <span>ç™½é»’æ„Ÿåº¦ <span id="val-thr">90</span></span>
        <span>åˆ¤å®šã®ç”˜ã• <span id="val-tol">0.6</span></span>
    </div>
    <input type="range" min="10" max="200" value="90" oninput="updateParam('thr', this.value)">
    <input type="range" min="0.1" max="1.0" step="0.05" value="0.6" oninput="updateParam('tol', this.value)" style="margin-top:5px;">
    <div style="font-size:10px; color:#aaa; margin-top:5px; text-align:center;">
        â€»å°åˆ·ã—ãŸãƒãƒƒãƒˆã‚’ç”»é¢ã«æ˜ ã™ã¨ã€è‡ªå‹•çš„ã«ã‚«ãƒ¼ãƒ‰ä½ç½®ã‚’èªè­˜ã—ã¾ã™ã€‚
    </div>
</div>

<div id="status-msg">ä¿å­˜ã—ã¾ã—ãŸ</div>
<video id="video-source" autoplay playsinline muted></video>

<div id="settings-overlay">
    <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
        <h2>è¨­å®š</h2><button onclick="closeSettings()" class="btn-float" style="margin:0; background:#555;">é–‰ã˜ã‚‹</button>
    </div>
    
    <div class="setting-box">
        <h3>1. å°‚ç”¨ãƒãƒƒãƒˆ (å¿…é ˆ)</h3>
        <p style="font-size:12px; color:#ccc;">ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯å°‚ç”¨ãƒãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚<br>ä»¥ä¸‹ã®ãƒœã‚¿ãƒ³ã‹ã‚‰ãƒãƒƒãƒˆã‚’è¡¨ç¤ºã—ã€å°åˆ·ã—ã¦ãã ã•ã„ã€‚</p>
        <button onclick="printMat()" style="width:100%; padding:15px; background:#e0a800; color:#000; border:none; border-radius:5px; font-weight:bold; font-size:16px;">ğŸ–¨ï¸ å°‚ç”¨ãƒãƒƒãƒˆã‚’è¡¨ç¤ºãƒ»å°åˆ·</button>
    </div>

    <div class="setting-box">
        <h3>2. ç”»åƒç™»éŒ²</h3>
        <p style="font-size:12px; color:#f88; margin-bottom:5px;">â€»ä¸å…·åˆæ™‚ã¯ã€Œå…¨å‰Šé™¤ã€ã—ã¦ã‹ã‚‰å†ç™»éŒ²ã—ã¦ãã ã•ã„</p>
        <input type="text" id="reg-name" placeholder="ã‚«ãƒ¼ãƒ‰å (ä¾‹: â˜…, A, ç©ºç™½)">
        <div style="background:#333; padding:8px; margin-bottom:10px; border-radius:4px;">
            <label style="cursor:pointer; display:flex; align-items:center;">
                <input type="checkbox" id="is-blank-check" style="width:20px; margin-right:5px;"> 
                ã“ã‚Œã‚’ã€Œç©ºç™½ã€ã¨ã—ã¦ç™»éŒ²ã™ã‚‹
            </label>
        </div>
        <label class="btn-float" style="display:block; text-align:center; margin:0; background:#007bff; border:none; font-size:14px; padding:12px;">
            ğŸ“ ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ç™»éŒ²
            <input type="file" accept="image/*" onchange="registerImage(this)" style="display:none;">
        </label>
        <div class="card-list" id="reg-list"></div>
    </div>

    <div class="setting-box">
        <h3>3. å•é¡Œä½œæˆãƒ»ç·¨é›†</h3>
        <input type="hidden" id="edit-index" value="-1">
        <input type="text" id="lvl-name" placeholder="å•é¡Œã‚¿ã‚¤ãƒˆãƒ« (ä¾‹: ãƒ¬ãƒ™ãƒ«1)">
        <div style="display:flex; gap:5px; margin-bottom:10px;">
            <select id="sel-0"></select><select id="sel-1"></select><select id="sel-2"></select><select id="sel-3"></select>
        </div>
        <button id="add-btn" onclick="addOrUpdateLevel()" style="width:100%; padding:12px; background:#28a745; color:#fff; border:none; border-radius:5px; font-weight:bold;">ï¼‹ ãƒªã‚¹ãƒˆã«è¿½åŠ </button>
        <button id="cancel-btn" onclick="cancelEdit()" style="width:100%; padding:8px; background:#666; color:#fff; border:none; border-radius:5px; margin-top:5px; display:none;">ç·¨é›†ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <div style="margin-top:15px; border-top:1px solid #444; padding-top:10px;">
            <div id="settings-level-list" class="level-list-container"></div>
        </div>
    </div>

    <div class="setting-box">
        <h3>ãƒ‡ãƒ¼ã‚¿ç®¡ç†</h3>
        <button onclick="downloadHTML()" style="width:100%; padding:10px; background:#007bff; color:#fff; border:none; border-radius:5px; margin-bottom:10px;">ğŸ’¾ è¨­å®šè¾¼ã¿HTMLã‚’ä¿å­˜</button>
        <button onclick="startHost()" style="width:100%; padding:10px; background:#007bff; color:#fff; border:none; border-radius:5px; margin-bottom:10px;">ğŸ“¡ QRåŒæœŸ (PCâ†’ã‚¹ãƒãƒ›)</button>
        <button onclick="resetData()" style="width:100%; padding:10px; background:#d00; color:#fff; border:none; border-radius:5px;">âš  å…¨å‰Šé™¤ (ãƒªã‚»ãƒƒãƒˆ)</button>
        <div id="sync-area" style="display:none; background:#fff; padding:10px; margin-top:10px; text-align:center; border-radius:8px;">
            <div id="qrcode"></div><div id="sync-msg" style="color:#000; font-size:11px;">å¾…æ©Ÿä¸­...</div>
        </div>
    </div>
</div>

<div id="result-view" onclick="this.style.display='none'">
    <div id="res-msg" style="font-size:4rem; font-weight:bold;"></div>
    <div style="font-size:1.2rem; opacity:0.8;">Tap to close</div>
</div>

<script id="embedded-data" type="application/json">null</script>

<script>
    // --- ã‚·ã‚¹ãƒ†ãƒ å®šæ•° ---
    // å†…éƒ¨å‡¦ç†ç”¨ã®è§£åƒåº¦ (ARè£œæ­£å¾Œã®çœŸã£ç›´ããªç”»åƒã®ã‚µã‚¤ã‚º)
    // A4ç”¨ç´™æ¯”ç‡ã«è¿‘ã„ 320x220 ã§å‡¦ç†
    const MAT_W = 320; 
    const MAT_H = 220; 
    
    // ã‚«ãƒ¼ãƒ‰æ¯”ç‡ (88/63 = 1.4)
    const CARD_ASPECT = 88 / 63;
    
    // ãƒãƒƒãƒˆä¸Šã®ã‚«ãƒ¼ãƒ‰é…ç½®å®šç¾© (MAT_W, MAT_H ã«å¯¾ã™ã‚‹ç›¸å¯¾åº§æ¨™%)
    // ã‚«ãƒ¼ãƒ‰ã¯ç¸¦å‘ãã§ã€æ¨ªã«4ã¤ä¸¦ã¹ã‚‹
    const CARD_W_PCT = 0.16; // ã‚«ãƒ¼ãƒ‰å¹… (å°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹)
    const CARD_H_PCT = CARD_W_PCT * CARD_ASPECT * (MAT_W/MAT_H); // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒ
    const GAP_PCT = 0.05;
    // 4æšã‚’ä¸­å¤®ã«é…ç½®
    const TOTAL_W = (CARD_W_PCT * 4) + (GAP_PCT * 3);
    const START_X_PCT = (1.0 - TOTAL_W) / 2;
    const START_Y_PCT = 0.35; // ç¸¦ä½ç½®

    // ã‚¹ãƒ­ãƒƒãƒˆã®å®šç¾© [x, y, w, h] (0.0-1.0)
    const SLOTS_PCT = [];
    for(let i=0; i<4; i++){
        SLOTS_PCT.push({
            x: START_X_PCT + i*(CARD_W_PCT+GAP_PCT),
            y: START_Y_PCT,
            w: CARD_W_PCT,
            h: CARD_H_PCT
        });
    }

    // --- å¤‰æ•° ---
    let cards=[], levels=[], blankData=null;
    let currentOrder=[], detected=["","","",""];
    let currentTarget=[];
    let isGameMode = false;
    let threshold = 90; let tolerance = 0.6;
    let showBinarized = false;
    let detector = null;

    // DOM
    const video = document.getElementById('video-source');
    const canvas = document.getElementById('main-canvas'); // è¡¨ç¤ºç”¨
    const ctx = canvas.getContext('2d');
    const procCanvas = document.getElementById('proc-canvas'); // å†…éƒ¨è¨ˆç®—ç”¨
    const procCtx = procCanvas.getContext('2d');
    const guideMsg = document.getElementById('ar-guide-msg');

    window.onload = () => {
        try {
            const txt = document.getElementById('embedded-data').textContent;
            if(txt && txt!=="null") { const d=JSON.parse(txt); cards=d.cards; levels=d.levels; blankData=d.blank; }
            else loadLocal();
        } catch(e){ loadLocal(); }
        
        procCanvas.width = MAT_W; procCanvas.height = MAT_H; // å†…éƒ¨è§£åƒåº¦å›ºå®š
        renderUI();
        startCam();
        
        const u = new URLSearchParams(window.location.search);
        if(u.get('sync')) startClient(u.get('sync'));
        
        // Arucoãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºå™¨ã®åˆæœŸåŒ–
        if(typeof AR !== 'undefined') detector = new AR.Detector();
    };

    function updateParam(type, val) {
        if(type==='thr') { threshold=parseInt(val); document.getElementById('val-thr').innerText=threshold; }
        if(type==='tol') { tolerance=parseFloat(val); document.getElementById('val-tol').innerText=tolerance>=0.8?"ç”˜ã‚":tolerance.toFixed(2); }
    }
    function toggleViewMode() { showBinarized = !showBinarized; showToast(showBinarized ? "ç™½é»’ãƒ¢ãƒ¼ãƒ‰" : "ã‚«ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ‰"); }

    async function startCam(manual=false) {
        if(video.srcObject) video.srcObject.getTracks().forEach(t=>t.stop());
        try {
            // èƒŒé¢ã‚«ãƒ¡ãƒ©ã‚’å„ªå…ˆ
            const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } });
            video.srcObject = s;
            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                video.play(); setInterval(loop, 100);
            };
            if(manual) showToast("å†èµ·å‹•ã—ã¾ã—ãŸ");
        } catch(e) { 
            // å¤±æ•—ã—ãŸã‚‰é€šå¸¸ã‚«ãƒ¡ãƒ©
            navigator.mediaDevices.getUserMedia({video:true}).then(s=>{ 
                video.srcObject=s; video.onloadedmetadata=()=>{
                    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                    video.play(); setInterval(loop, 100);
                };
            });
        }
    }

    function loop() {
        if(video.readyState !== 4) return;
        const isTitle = document.getElementById('title-screen').style.display !== 'none';
        const isSettings = document.getElementById('settings-overlay').classList.contains('open');
        if(isTitle && !isSettings) return;

        // 1. ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’è¡¨ç¤ºç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const camData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        // 2. ARãƒãƒ¼ã‚«ãƒ¼æ¤œå‡º (Aruco)
        // æˆ»ã‚Šå€¤: { id: number, corners: [{x,y},...] } ã®é…åˆ—
        let corners = [null, null, null, null];
        let detectedMarkers = [];
        if(detector) {
            detectedMarkers = detector.detect(camData);
            detectedMarkers.forEach(m => { 
                // ID 0ï½3 ã‚’ä½¿ç”¨ (0:å·¦ä¸Š, 1:å³ä¸Š, 2:å³ä¸‹, 3:å·¦ä¸‹)
                if(m.id >= 0 && m.id <= 3) corners[m.id] = m.corners; 
            });
        }

        // 3. ãƒãƒ¼ã‚«ãƒ¼ãŒ4ã¤æƒã£ã¦ã„ã‚‹ã‹ï¼Ÿ
        const allFound = corners[0] && corners[1] && corners[2] && corners[3];
        guideMsg.style.display = (!allFound) ? 'block' : 'none';

        if(allFound) {
            // --- è£œæ­£å‡¦ç† ---
            
            // 4. ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£å¤‰æ›è¡Œåˆ—ã®è¨ˆç®—
            // ã‚½ãƒ¼ã‚¹: ã‚«ãƒ¡ãƒ©ç”»é¢ä¸Šã®ãƒãƒ¼ã‚«ãƒ¼ä¸­å¿ƒåº§æ¨™
            const centers = corners.map(c => {
                let sx=0, sy=0; c.forEach(p=>{sx+=p.x; sy+=p.y;});
                return {x:sx/4, y:sy/4};
            });
            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: å†…éƒ¨ã‚­ãƒ£ãƒ³ãƒã‚¹(procCanvas)ã®å››éš…
            // IDé…ç½®: 0:å·¦ä¸Š, 1:å³ä¸Š, 2:å³ä¸‹, 3:å·¦ä¸‹
            const srcPoints = [
                centers[0].x, centers[0].y, // å·¦ä¸Š
                centers[1].x, centers[1].y, // å³ä¸Š
                centers[2].x, centers[2].y, // å³ä¸‹
                centers[3].x, centers[3].y  // å·¦ä¸‹
            ];
            const dstPoints = [
                0, 0,            // å·¦ä¸Š
                MAT_W, 0,        // å³ä¸Š
                MAT_W, MAT_H,    // å³ä¸‹
                0, MAT_H         // å·¦ä¸‹
            ];
            
            const H = getHomography(srcPoints, dstPoints);

            // 5. å†…éƒ¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ã€ŒçœŸã£ç›´ããªç”»åƒã€ã‚’ç”Ÿæˆ (Warp)
            warpImage(camData, procCtx, H);

            // 6. å†…éƒ¨ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã§äºŒå€¤åŒ–ãƒ»åˆ¤å®š
            const procData = procCtx.getImageData(0,0,MAT_W, MAT_H);
            const bin = binarize(procData);
            
            // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º: ç™½é»’ãƒ¢ãƒ¼ãƒ‰ãªã‚‰è¡¨ç¤ºç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã«å†…éƒ¨ç”»åƒã‚’åˆæˆè¡¨ç¤º(ãƒ¯ã‚¤ãƒ—)
            if(showBinarized) {
                procCtx.putImageData(bin, 0, 0);
                ctx.drawImage(procCanvas, 10, 10, 160, 110); // å·¦ä¸Šã«å°ã•ãè¡¨ç¤º
                ctx.strokeStyle="red"; ctx.lineWidth=2; ctx.strokeRect(10,10,160,110);
            }

            // 7. åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ (procCanvasä¸Šã®åº§æ¨™ã§è¡Œã†)
            let detectedNow = [];
            
            // ç”»é¢æç”»è¨­å®š
            ctx.lineWidth = 2; ctx.font = "bold 16px sans-serif";

            // ãƒãƒ¼ã‚«ãƒ¼æ ã®ç·šã‚’çµã‚“ã§è¡¨ç¤º (èªè­˜ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯)
            ctx.strokeStyle = "#00ff00";
            ctx.beginPath();
            ctx.moveTo(centers[0].x, centers[0].y); ctx.lineTo(centers[1].x, centers[1].y);
            ctx.lineTo(centers[2].x, centers[2].y); ctx.lineTo(centers[3].x, centers[3].y);
            ctx.closePath(); ctx.stroke();

            for(let i=0; i<4; i++) {
                const slot = SLOTS_PCT[i];
                // å†…éƒ¨åº§æ¨™
                const tx = Math.floor(slot.x * MAT_W);
                const ty = Math.floor(slot.y * MAT_H);
                const tw = Math.floor(slot.w * MAT_W);
                const th = Math.floor(slot.h * MAT_H);
                
                // ç‰¹å¾´æŠ½å‡º (å†…éƒ¨ç”»åƒã‹ã‚‰)
                const feat = getFeature(bin, tx, ty, tw, th, MAT_W);
                
                // ç…§åˆ
                let best = "?"; let minD = 1.0;
                cards.forEach(c => {
                    if(c.isBlank) return;
                    const diff = compareShift(feat, c.data, tw, th, 4); 
                    if(diff < minD) { minD = diff; best = c.name; }
                });
                if(blankData) {
                    const bDiff = compareShift(feat, blankData, tw, th, 4);
                    if(bDiff < minD) { best = ""; minD = bDiff; }
                }
                
                if(minD > tolerance) best = "?";
                detectedNow.push(best);

                // --- ç”»é¢ä¸Šã«çµæœã‚’è¡¨ç¤º ---
                // å†…éƒ¨åº§æ¨™(tx, ty)ãªã©ã¯çœŸã£ç›´ãã ãŒã€ç”»é¢ä¸Šã§ã¯æ­ªã‚“ã§ã„ã‚‹ã€‚
                // 4éš…ã®ãƒãƒ¼ã‚«ãƒ¼ä½ç½®ã‹ã‚‰ç”»é¢ä¸Šã®åº§æ¨™ã‚’è£œé–“ã—ã¦ç‰¹å®šã™ã‚‹
                
                const disp = best==="" ? "ç©º" : best;
                
                // æ ã®è¡¨ç¤ºï¼ˆ4éš…ã‚’å¤‰æ›ã—ã¦æç”»ï¼‰
                ctx.strokeStyle = (best !== "?") ? "#00ffff" : "rgba(255,255,255,0.5)";
                drawDistortedRect(ctx, slot, corners);

                // ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºä½ç½®
                const screenP = mapPointToScreen(slot.x + slot.w/2, slot.y + slot.h/2, corners);
                ctx.fillStyle = "#fff";
                ctx.textAlign = "center";
                ctx.shadowColor = "black"; ctx.shadowBlur = 4;
                ctx.fillText(disp, screenP.x, screenP.y);
                ctx.shadowBlur = 0;
            }
            detected = detectedNow;

        } else {
            // ãƒãƒ¼ã‚«ãƒ¼ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
            // ã‚¬ã‚¤ãƒ‰è¡¨ç¤ºæ¸ˆã¿
        }
    }

    // --- åº§æ¨™å¤‰æ›ç³» ---
    function mapPointToScreen(pctX, pctY, corners) {
        // 4éš…ã®åº§æ¨™ã‹ã‚‰ã€ãƒã‚¤ãƒªãƒ‹ã‚¢è£œé–“ã§ç”»é¢ä¸Šã®åº§æ¨™ã‚’æ¨å®š
        // corners: 0:TL, 1:TR, 2:BR, 3:BL
        // ä¸Šè¾ºã®ç‚¹ (Left -> Right)
        const topX = corners[0][0].x + (corners[1][1].x - corners[0][0].x) * pctX;
        const topY = corners[0][0].y + (corners[1][1].y - corners[0][0].y) * pctX;
        // ä¸‹è¾ºã®ç‚¹ (Left -> Right)
        const btmX = corners[3][3].x + (corners[2][2].x - corners[3][3].x) * pctX;
        const btmY = corners[3][3].y + (corners[2][2].y - corners[3][3].y) * pctX;
        // ä¸Šä¸‹ã‚’çµã‚“ã§Yå‰²åˆã§ç‚¹ã‚’ã‚‚ã¨ã‚ã‚‹
        return {
            x: topX + (btmX - topX) * pctY,
            y: topY + (btmY - topY) * pctY
        };
    }
    
    function drawDistortedRect(ctx, slot, corners) {
        // ã‚¹ãƒ­ãƒƒãƒˆã®4éš…ã‚’ç”»é¢åº§æ¨™ã«å¤‰æ›ã—ã¦ãƒ‘ã‚¹ã‚’æã
        const p1 = mapPointToScreen(slot.x, slot.y, corners); // TL
        const p2 = mapPointToScreen(slot.x+slot.w, slot.y, corners); // TR
        const p3 = mapPointToScreen(slot.x+slot.w, slot.y+slot.h, corners); // BR
        const p4 = mapPointToScreen(slot.x, slot.y+slot.h, corners); // BL
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
        ctx.closePath(); ctx.stroke();
    }

    // --- ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£ & Warp ---
    function getHomography(src, dst) {
        // src: [x0,y0, x1,y1, x2,y2, x3,y3]
        let n = 4; 
        let A = []; let B = [];
        for(let i=0; i<n; i++) {
            let sx = src[i*2], sy = src[i*2+1];
            let dx = dst[i*2], dy = dst[i*2+1];
            A.push([sx, sy, 1, 0, 0, 0, -sx*dx, -sy*dx]);
            A.push([0, 0, 0, sx, sy, 1, -sx*dy, -sy*dy]);
            B.push(dx); B.push(dy);
        }
        const sol = solveGaussian(A, B);
        return [sol[0], sol[1], sol[2], sol[3], sol[4], sol[5], sol[6], sol[7], 1.0];
    }
    function solveGaussian(A, B) {
        let n = A.length;
        for (let i=0; i<n; i++) {
            let maxEl = Math.abs(A[i][i]), maxRow = i;
            for (let k=i+1; k<n; k++) if (Math.abs(A[k][i]) > maxEl) { maxEl = Math.abs(A[k][i]); maxRow = k; }
            for (let k=i; k<n; k++) { let tmp=A[maxRow][k]; A[maxRow][k]=A[i][k]; A[i][k]=tmp; }
            let tmp=B[maxRow]; B[maxRow]=B[i]; B[i]=tmp;
            for (let k=i+1; k<n; k++) {
                let c = -A[k][i]/A[i][i];
                for (let j=i; j<n; j++) if (i==j) A[k][j]=0; else A[k][j] += c * A[i][j];
                B[k] += c * B[i];
            }
        }
        let x = new Array(n);
        for (let i=n-1; i>-1; i--) {
            let sum = 0; for (let j=i+1; j<n; j++) sum += A[i][j] * x[j];
            x[i] = (B[i] - sum) / A[i][i];
        }
        return x;
    }
    function warpImage(srcImg, ctxDst, H) {
        // Inverse mapping
        const w = MAT_W; const h = MAT_H;
        const dstData = ctxDst.createImageData(w, h);
        const dd = dstData.data;
        const d = srcImg.data;
        const sw = srcImg.width; const sh = srcImg.height;

        const H_inv = invertMatrix3x3(H);

        for(let y=0; y<h; y++) {
            for(let x=0; x<w; x++) {
                const u = H_inv[0]*x + H_inv[1]*y + H_inv[2];
                const v = H_inv[3]*x + H_inv[4]*y + H_inv[5];
                const s = H_inv[6]*x + H_inv[7]*y + H_inv[8];
                const srcX = Math.floor(u/s);
                const srcY = Math.floor(v/s);

                const dstIdx = (y*w + x)*4;
                if(srcX >=0 && srcX < sw && srcY >=0 && srcY < sh) {
                    const srcIdx = (srcY*sw + srcX)*4;
                    dd[dstIdx] = d[srcIdx];
                    dd[dstIdx+1] = d[srcIdx+1];
                    dd[dstIdx+2] = d[srcIdx+2];
                    dd[dstIdx+3] = 255;
                } else {
                    dd[dstIdx+3] = 0;
                }
            }
        }
        ctxDst.putImageData(dstData, 0, 0);
    }
    function invertMatrix3x3(m) {
        const n11=m[0], n12=m[1], n13=m[2], n21=m[3], n22=m[4], n23=m[5], n31=m[6], n32=m[7], n33=m[8];
        const t11 = n33*n22 - n32*n23, t12 = n32*n13 - n33*n12, t13 = n23*n12 - n22*n13;
        const det = n11*t11 + n21*t12 + n31*t13;
        if(det===0) return m; 
        const idet = 1/det;
        return [
            t11*idet, (n31*n23 - n33*n21)*idet, (n32*n21 - n31*n22)*idet,
            t12*idet, (n33*n11 - n31*n13)*idet, (n31*n12 - n32*n11)*idet,
            t13*idet, (n21*n13 - n23*n11)*idet, (n22*n11 - n21*n12)*idet
        ];
    }

    // --- ç”»åƒç™»éŒ² (Smart Matå¯¾å¿œ) ---
    function registerImage(input) {
        if(!input.files[0]) return;
        const name = document.getElementById('reg-name').value || "Card"+(cards.length+1);
        const isBlank = document.getElementById('is-blank-check').checked;
        const r = new FileReader();
        r.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const c = document.createElement('canvas');
                // å†…éƒ¨å‡¦ç†ã‚µã‚¤ã‚ºã¨åŒã˜æ¯”ç‡ã®è§£åƒåº¦ã«ã™ã‚‹
                const tw = Math.floor(MAT_W * CARD_W_PCT);
                const th = Math.floor(MAT_H * CARD_H_PCT);
                c.width = tw; c.height = th;
                const tx = c.getContext('2d');
                tx.drawImage(img, 0, 0, tw, th); 
                
                const b = binarize(tx.getImageData(0,0,tw,th));
                const data = getFeature(b, 0, 0, tw, th, tw);
                tx.putImageData(b, 0, 0); 
                const thumb = c.toDataURL();

                if(isBlank) {
                    blankData = data;
                    cards = cards.filter(x=>!x.isBlank);
                    cards.unshift({name:"ã€ç©ºç™½ã€‘"+name, data, thumb, isBlank:true});
                    showToast("ç©ºç™½ã¨ã—ã¦ç™»éŒ²ã—ã¾ã—ãŸ");
                } else {
                    cards.push({name, data, thumb, isBlank:false});
                    showToast("ç™»éŒ²ã—ã¾ã—ãŸ");
                }
                saveLocal(); renderUI();
                input.value=""; document.getElementById('reg-name').value=""; document.getElementById('is-blank-check').checked=false;
            };
            img.src = e.target.result;
        };
        r.readAsDataURL(input.files[0]);
    }

    function binarize(d) {
        const bin=new ImageData(d.width,d.height); const bd=bin.data; const dd=d.data;
        for(let i=0;i<dd.length;i+=4) {
            const v = (dd[i]+dd[i+1]+dd[i+2])/3 < threshold ? 0 : 255;
            bd[i]=bd[i+1]=bd[i+2]=v; bd[i+3]=255;
        }
        return bin;
    }
    function getFeature(b,x,y,w,h,tw) {
        const p=[]; const d=b.data; const step=2;
        for(let py=0; py<h; py+=step) for(let px=0; px<w; px+=step) {
            const idx = ((y+py)*tw + (x+px)) * 4; p.push(d[idx]===0 ? 1 : 0);
        }
        return p;
    }
    function compareShift(a, b, w, h, range) {
        if(!a || !b || a.length !== b.length) return 1.0;
        let minDiff = 1.0;
        minDiff = Math.min(minDiff, simpleCompare(a,b,0));
        for(let s=1; s<=range; s++) {
            minDiff = Math.min(minDiff, simpleCompare(a,b,s));
            minDiff = Math.min(minDiff, simpleCompare(a,b,-s));
        }
        return minDiff;
    }
    function simpleCompare(a,b,offset) {
        let diff=0; let cnt=0; const len=a.length;
        for(let i=0; i<len; i++) {
            let ai = i+offset;
            if(ai>=0 && ai<len) { if(a[ai]!==b[i]) diff++; cnt++; }
        }
        return cnt===0?1.0 : diff/cnt;
    }

    // --- å°åˆ·ç”¨ãƒãƒƒãƒˆç”Ÿæˆ ---
    function printMat() {
        const w = window.open('', '_blank');
        // Aruco 4x4 ID:0,1,2,3 ã®Base64ç”»åƒ
        const m0="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAAACVBMVEUAAAD///8AAABz1c1UAAAAKElEQVQ4y2P4DwM8YICgA4b/YICiA4b/oICqA4b/sICuA4b/8ICyAwYAm3c/wXW1m1sAAAAASUVORK5CYII=";
        const m1="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAAACVBMVEUAAAD///8AAABz1c1UAAAALElEQVQ4y2P4DwM8YICgA4b/YICiA4b/oICqA4b/sICuA4b/8ICyAwYA8z/Bdf2l2x4AAAAASUVORK5CYII=";
        const m2="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAAACVBMVEUAAAD///8AAABz1c1UAAAAK0lEQVQ4y2P4DwM8YICgA4b/YICiA4b/oICqA4b/sICuA4b/8ICyAwYA0j/Bda0r2yAAAAAASUVORK5CYII=";
        const m3="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAAACVBMVEUAAAD///8AAABz1c1UAAAAKUlEQVQ4y2P4DwM8YICgA4b/YICiA4b/oICqA4b/sICuA4b/8ICyAwYAk3c/wW062yAAAAAASUVORK5CYII=";

        w.document.write(`
        <html><head><title>Card Master Mat</title>
        <style>
            body{margin:0; text-align:center; font-family:sans-serif;}
            .page { width:297mm; height:210mm; border:1px solid #ddd; position:relative; margin:0 auto; box-sizing:border-box; padding:10mm; }
            .marker { position:absolute; width:30mm; height:30mm; border:1px solid #ddd; }
            .marker img { width:100%; height:100%; image-rendering: pixelated; }
            .slot-container { position:absolute; top:35%; left:50%; transform:translate(-50%, 0); width:80%; display:flex; justify-content:center; gap:5%; }
            .slot { width:16%; aspect-ratio: 63/88; border: 3px solid #000; border-radius:4px; display:flex; align-items:center; justify-content:center; color:#000; font-weight:bold; font-size:24px;}
            
            /* ã‚·ã‚¹ãƒ†ãƒ èªè­˜é †åºã«åˆã‚ã›ãŸé…ç½® (ID:0=TL, 1=TR, 2=BR, 3=BL) */
            #m0 { top:10mm; left:10mm; }
            #m1 { top:10mm; right:10mm; }
            #m2 { bottom:10mm; right:10mm; }
            #m3 { bottom:10mm; left:10mm; }
            
            @media print { .page { border:none; } button {display:none;}}
        </style>
        </head><body>
        <div class="page">
            <div id="m0" class="marker"><img src="${m0}"></div>
            <div id="m1" class="marker"><img src="${m1}"></div>
            <div class="slot-container">
                <div class="slot">1</div><div class="slot">2</div><div class="slot">3</div><div class="slot">4</div>
            </div>
            <div id="m3" class="marker"><img src="${m3}"></div>
            <div id="m2" class="marker"><img src="${m2}"></div>
            <div style="position:absolute; bottom:5mm; width:100%; text-align:center; font-size:12px;">CARD MASTER å°‚ç”¨ãƒãƒƒãƒˆ (A4æ¨ª)</div>
        </div>
        <button onclick="window.print()" style="font-size:20px; padding:10px 20px; margin-top:20px; cursor:pointer;">ğŸ–¨ï¸ å°åˆ·ã™ã‚‹</button>
        </body></html>
        `);
    }

    // --- UIé–¢é€£ ---
    function addOrUpdateLevel() {
        const t = document.getElementById('lvl-name').value || "ç„¡é¡Œ";
        const o = [0,1,2,3].map(i => document.getElementById(`sel-${i}`).value);
        const idx = parseInt(document.getElementById('edit-index').value);
        if(idx>=0) { levels[idx]={title:t, order:o}; showToast("æ›´æ–°ã—ã¾ã—ãŸ"); }
        else { levels.push({title:t, order:o}); showToast("è¿½åŠ ã—ã¾ã—ãŸ"); }
        cancelEdit(); saveLocal(); renderUI();
    }
    function editLevel(i) {
        const l=levels[i]; document.getElementById('lvl-name').value=l.title;
        for(let j=0;j<4;j++) document.getElementById(`sel-${j}`).value=l.order[j];
        document.getElementById('edit-index').value=i;
        document.getElementById('add-btn').innerText="æ›´æ–°";
        document.getElementById('cancel-btn').style.display="inline-block";
    }
    function cancelEdit() {
        document.getElementById('lvl-name').value="";
        for(let j=0;j<4;j++) document.getElementById(`sel-${j}`).value="";
        document.getElementById('edit-index').value="-1";
        document.getElementById('add-btn').innerText="ï¼‹ è¿½åŠ ";
        document.getElementById('cancel-btn').style.display="none";
    }
    function renderUI() {
        const cl = document.getElementById('reg-list'); cl.innerHTML="";
        cards.forEach((c,i)=>{
            const style = c.isBlank ? "border:2px dashed #0f0;" : "";
            cl.innerHTML+=`<div class="card-thumb" style="${style}"><img src="${c.thumb}"><div class="card-name">${c.name}</div><div style="position:absolute;top:0;right:0;background:red;width:20px;color:white;text-align:center;cursor:pointer;" onclick="if(confirm('å‰Šé™¤?')){cards.splice(${i},1);if(c.isBlank)blankData=null;saveLocal();renderUI();}">Ã—</div></div>`;
        });
        for(let i=0;i<4;i++){
            const s=document.getElementById(`sel-${i}`); const v=s.value; s.innerHTML="<option value=''>- ç©ºç™½ -</option>";
            cards.forEach(c=>{ if(!c.isBlank) s.innerHTML+=`<option value='${c.name}'>${c.name}</option>`; });
            s.value=v;
        }
        const tl = document.getElementById('title-level-list'); tl.innerHTML="";
        if(levels.length===0) tl.innerHTML="<div style='color:#777;margin-top:20px;'>â€»å³ä¸Šã®è¨­å®šâš™ï¸ã‹ã‚‰å•é¡Œã‚’ä½œæˆã—ã¦ãã ã•ã„</div>";
        levels.forEach((l,i)=>{
            tl.innerHTML+=`
            <div style="background:rgba(255,255,255,0.1); padding:15px; margin-bottom:10px; border-radius:10px; display:flex; justify-content:space-between; align-items:center; cursor:pointer; border:1px solid #555;" onclick="startGame(${i})">
                <span style="font-weight:bold; font-size:16px;">${l.title}</span>
                <span style="background:#007bff; padding:5px 10px; border-radius:15px; font-size:12px;">æŒ‘æˆ¦ â–¶</span>
            </div>`;
        });
        const sl = document.getElementById('settings-level-list'); sl.innerHTML="";
        levels.forEach((l,i)=>{
            const detail = l.order.map(n=>n===""?"_":n).join(", ");
            sl.innerHTML+=`
            <div class="level-row">
                <div class="level-row-header">
                    <span style="font-weight:bold;">${l.title}</span>
                    <div><button class="btn-mini btn-edit" onclick="editLevel(${i})">ç·¨é›†</button><button class="btn-mini btn-del" onclick="if(confirm('å‰Šé™¤?')){levels.splice(${i},1);saveLocal();renderUI();}">å‰Šé™¤</button></div>
                </div>
                <div style="font-size:11px;color:#aaa;">æ­£è§£: ${detail}</div>
            </div>`;
        });
    }

    function startGame(i) { 
        currentTarget=levels[i].order; isGameMode=true; 
        document.getElementById('title-screen').style.display = 'none'; 
        document.getElementById('game-ui').style.display = 'flex'; 
    }
    function goTitle() { 
        isGameMode=false; 
        document.getElementById('title-screen').style.display = 'flex'; 
        document.getElementById('game-ui').style.display = 'none'; 
    }
    function judge() { 
        const isMatch = JSON.stringify(detected) === JSON.stringify(currentTarget); 
        const m = document.getElementById('res-msg'); 
        m.innerText=isMatch?"æ­£è§£!!":"ä¸æ­£è§£..."; m.style.color=isMatch?"#0f0":"#f00";
        document.getElementById('result-view').style.display='flex';
    }

    function saveLocal() { localStorage.setItem('cm_v23_data', JSON.stringify({cards,levels,blank:blankData})); }
    function loadLocal() { const d=localStorage.getItem('cm_v23_data'); if(d){ const j=JSON.parse(d); cards=j.cards; levels=j.levels; blankData=j.blank;} }
    function resetData() { if(confirm("å…¨æ¶ˆå»?")) { localStorage.clear(); location.reload(); } }
    function showToast(m) { const e=document.getElementById('status-msg'); e.innerText=m; e.style.opacity=1; setTimeout(()=>e.style.opacity=0,2000); }
    function openSettings() { document.getElementById('settings-overlay').classList.add('open'); }
    function closeSettings() { document.getElementById('settings-overlay').classList.remove('open'); cancelEdit(); }
    
    function downloadHTML() {
        let html = document.documentElement.outerHTML;
        const data = JSON.stringify({ cards, levels, blank: blankData });
        const tag = '\x3cscript id="embedded-data" type="application/json"\x3e' + data + '\x3c/script\x3e';
        html = html.replace(/<script id="embedded-data" type="application\/json">.*?<\/script>/i, tag);
        const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([html], {type:"text/html"})); a.download = "index.html"; a.click();
    }
    
    let peer=null;
    function startHost(){ if(typeof Peer==='undefined'){alert("é€šä¿¡ã‚¨ãƒ©ãƒ¼");return;} if(peer)peer.destroy(); peer=new Peer(); document.getElementById('sync-area').style.display='block'; document.getElementById('sync-msg').innerText="å¾…æ©Ÿä¸­..."; peer.on('open',id=>{ new QRCode(document.getElementById('qrcode'),{text:window.location.href.split('?')[0]+"?sync="+id,width:128,height:128});}); peer.on('connection',c=>{c.on('open',()=>c.send({cards,levels,blank:blankData}));});}
    function startClient(id){ if(peer)peer.destroy(); peer=new Peer(); peer.on('open',()=>{ const c=peer.connect(id); c.on('data',d=>{cards=d.cards;levels=d.levels;blankData=d.blank;saveLocal();renderUI();showToast("åŒæœŸå®Œäº†");window.history.replaceState({},document.title,window.location.pathname);}); });}
</script>
</body>
</html>
