<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bluff Quiz Master V2</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #222; color: #fff; margin: 0; padding: 20px; text-align: center; }
        h1 { color: #f39c12; text-shadow: 2px 2px #000; margin-bottom: 10px; }
        .hidden { display: none !important; }
        .screen { max-width: 800px; margin: 0 auto; background: #333; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        /* Input & Button */
        input, textarea { width: 90%; padding: 10px; margin: 5px 0; border-radius: 5px; border: none; font-size: 16px; }
        button { background: #e74c3c; color: white; border: none; padding: 10px 20px; border-radius: 5px; font-size: 18px; cursor: pointer; margin: 10px; transition: 0.2s; }
        button:hover { background: #c0392b; }
        button:disabled { background: #555; cursor: not-allowed; }
        .btn-opt { background: #3498db; width: 100%; margin: 10px 0; text-align: left; }
        .btn-opt:hover { background: #2980b9; }
        .btn-copy { background: #27ae60; font-size: 14px; padding: 5px 10px; }

        /* Lists */
        ul { list-style: none; padding: 0; }
        li { background: #444; margin: 5px 0; padding: 10px; border-radius: 5px; position: relative; }
        
        /* Specific Styles */
        #qrcode { margin: 20px auto; background: #fff; padding: 10px; width: 150px; }
        .status { font-weight: bold; color: #2ecc71; margin: 10px 0; }
        .big-text { font-size: 24px; font-weight: bold; margin: 20px 0; line-height: 1.4; }
        .score-box { display: flex; justify-content: space-between; border-bottom: 1px solid #555; padding: 5px; }
        
        /* Vote & Result Display */
        .voter-tag { 
            display: inline-block; background: #9b59b6; color: #fff; 
            font-size: 12px; padding: 2px 6px; border-radius: 4px; margin-left: 5px; 
            vertical-align: middle;
        }
        .author-tag {
            display: block; font-size: 12px; color: #aaa; text-align: right; margin-top: 5px;
        }
        .res-correct { color: #2ecc71; font-weight: bold; }
        .res-wrong { color: #e74c3c; }
        
        .opt-row { text-align: left; font-size: 18px; }
        .real-answer-box { border: 2px solid #2ecc71; background: rgba(46, 204, 113, 0.1); }
    </style>
</head>
<body>

<div id="host-setup" class="screen">
    <h1>Bluff Quiz Master V2</h1>
    <div style="text-align: left; margin-bottom: 20px;">
        <h3>① 問題の登録</h3>
        <input type="text" id="new-q" placeholder="問題文 (例: 英単語「Aglet」の意味は？)">
        <input type="text" id="new-a" placeholder="正解 (例: 靴紐の先端の固い部分)">
        <button onclick="addQuestion()">追加</button>
        <ul id="q-list"></ul>
    </div>
    <hr>
    <div>
        <h3>② 部屋の作成</h3>
        <p>参加人数を設定してください</p>
        <input type="number" id="player-count" value="3" min="2" style="width: 60px;"> 人
        <br>
        <button onclick="startHost()">部屋を作成 (QR表示)</button>
    </div>
</div>

<div id="host-lobby" class="screen hidden">
    <h1>参加者待機中...</h1>
    <div style="display:flex; justify-content:center; align-items:center; flex-direction:column;">
        <div id="qrcode"></div>
        <div>
            <input type="text" id="room-url-input" readonly style="width:200px; font-size:12px;">
            <button class="btn-copy" onclick="copyUrl()">URLコピー</button>
        </div>
    </div>
    <div class="status">現在の参加者: <span id="joined-count">0</span> / <span id="max-count">0</span></div>
    <ul id="player-list"></ul>
    <div id="q-selector">
        <h3>問題を選択してスタート</h3>
        <div id="q-buttons"></div>
    </div>
</div>

<div id="host-input-phase" class="screen hidden">
    <h1>偽の選択肢を考えろ！</h1>
    <div class="big-text" id="host-q-text"></div>
    <p>参加者の回答を待っています...</p>
    <div class="status">回答済み: <span id="input-done-count">0</span> 人</div>
</div>

<div id="host-vote-phase" class="screen hidden">
    <h1>正解はどれだ！？</h1>
    <div class="big-text" id="vote-q-text"></div>
    <ul id="options-display"></ul> <div id="voting-status-msg">
        <p>投票を待っています...</p>
        <div class="status">投票済み: <span id="vote-done-count">0</span> 人</div>
    </div>

    <button id="btn-show-result" class="hidden" onclick="calcResults()">結果発表へ</button>
</div>

<div id="host-result" class="screen hidden">
    <h1>結果発表</h1>
    <h2 id="real-answer-display" style="color:#2ecc71;"></h2>
    
    <div style="text-align: left;">
        <h3>選択肢の詳細</h3>
        <ul id="options-detail-list"></ul>
    </div>
    
    <hr>
    <h3>現在のトータルスコア</h3>
    <div id="total-scores" style="text-align: left;"></div>
    <button onclick="backToLobby()">次の問題へ</button>
</div>


<div id="client-login" class="screen hidden">
    <h1>参加登録</h1>
    <p>ニックネームを入力してください</p>
    <input type="text" id="my-name" placeholder="名前 (例: タナカ)">
    <button onclick="joinGame()">ゲームに参加</button>
</div>

<div id="client-wait" class="screen hidden">
    <h2>待機中...</h2>
    <p>ホストが問題を選ぶのを待っています</p>
</div>

<div id="client-input" class="screen hidden">
    <h2>問題</h2>
    <p id="cli-q-text" style="font-weight: bold; font-size:18px;"></p>
    <hr>
    <p>みんなを騙す「偽の正解」を入力せよ！</p>
    <input type="text" id="fake-answer" placeholder="偽の答え...">
    <button onclick="submitFakeAnswer()">送信</button>
</div>

<div id="client-vote" class="screen hidden">
    <h2>どれが正解？</h2>
    <div id="cli-options"></div>
</div>

<div id="client-result" class="screen hidden">
    <h2>結果</h2>
    <p id="cli-result-msg"></p>
    <p>次の問題を待っています...</p>
</div>


<script>
    // --- Global Variables ---
    let peer, conn;
    let myId = null;
    let hostConn = null; // Client side
    let connections = {}; // Host side: {peerId: conn}
    let players = {}; // {peerId: {name, score, fakeAnswer, vote}}
    let questions = [
        {q: "「たほいや」の意味は？", a: "イノシシを追い払う小屋"},
        {q: "「アグレット」の意味は？", a: "靴紐の先端の固い部分"},
    ];
    let currentQ = null;
    let maxPlayers = 3;
    let isHost = false;

    // --- Init ---
    window.onload = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const hostId = urlParams.get('host');

        if (hostId) {
            // Client Mode
            isHost = false;
            initClient(hostId);
        } else {
            // Host Mode (Default)
            isHost = true;
            document.getElementById('host-setup').classList.remove('hidden');
            renderQList();
        }
    };

    // ================= HOST LOGIC =================

    function addQuestion() {
        const q = document.getElementById('new-q').value;
        const a = document.getElementById('new-a').value;
        if(q && a){
            questions.push({q, a});
            document.getElementById('new-q').value = "";
            document.getElementById('new-a').value = "";
            renderQList();
        }
    }

    function renderQList() {
        const list = document.getElementById('q-list');
        list.innerHTML = questions.map((item, i) => `<li>Q: ${item.q} / A: ${item.a}</li>`).join('');
        
        const btnDiv = document.getElementById('q-buttons');
        btnDiv.innerHTML = questions.map((item, i) => 
            `<button onclick="startGame(${i})">Q. ${item.q}</button>`
        ).join('');
    }

    function startHost() {
        maxPlayers = parseInt(document.getElementById('player-count').value);
        document.getElementById('max-count').innerText = maxPlayers;
        
        peer = new Peer();
        peer.on('open', (id) => {
            myId = id;
            showScreen('host-lobby');
            
            // Generate QR & URL
            const url = `${location.href.split('?')[0]}?host=${myId}`;
            new QRCode(document.getElementById("qrcode"), { text: url, width: 128, height: 128 });
            document.getElementById('room-url-input').value = url;

            peer.on('connection', (c) => {
                c.on('open', () => {
                    setupHostConnection(c);
                });
            });
        });
    }

    function copyUrl() {
        const copyText = document.getElementById("room-url-input");
        copyText.select();
        copyText.setSelectionRange(0, 99999); 
        navigator.clipboard.writeText(copyText.value).then(() => {
            alert("URLをコピーしました！");
        });
    }

    function setupHostConnection(c) {
        c.on('data', (data) => {
            if (data.type === 'JOIN') {
                connections[c.peer] = c;
                players[c.peer] = { name: data.name, score: 0, fakeAnswer: '', vote: '' };
                updatePlayerList();
            } else if (data.type === 'FAKE_ANSWER') {
                players[c.peer].fakeAnswer = data.answer;
                checkAllInputsReceived();
            } else if (data.type === 'VOTE') {
                players[c.peer].vote = data.vote; // vote is index
                checkAllVotesReceived();
            }
        });
    }

    function updatePlayerList() {
        const list = document.getElementById('player-list');
        list.innerHTML = Object.values(players).map(p => `<li>${p.name} (Pt: ${p.score})</li>`).join('');
        document.getElementById('joined-count').innerText = Object.keys(players).length;
    }

    function startGame(qIndex) {
        if (Object.keys(players).length < 2) {
            // alert("最低2人の参加者が必要です"); 
            // return; // Debug用にコメントアウト
        }
        currentQ = questions[qIndex];
        
        // Reset Round Data
        Object.keys(players).forEach(pid => {
            players[pid].fakeAnswer = '';
            players[pid].vote = '';
        });

        // Broadcast Question
        broadcast({ type: 'START_INPUT', q: currentQ.q });
        
        document.getElementById('host-q-text').innerText = currentQ.q;
        document.getElementById('input-done-count').innerText = "0";
        showScreen('host-input-phase');
    }

    function checkAllInputsReceived() {
        const pIds = Object.keys(players);
        const done = pIds.filter(pid => players[pid].fakeAnswer !== '').length;
        document.getElementById('input-done-count').innerText = done;

        if (done === pIds.length) {
            startVotingPhase();
        }
    }

    function startVotingPhase() {
        // Collect options
        let options = [{ text: currentQ.a, owner: 'SYSTEM' }];
        Object.keys(players).forEach(pid => {
            options.push({ text: players[pid].fakeAnswer, owner: pid });
        });

        // Shuffle
        options = shuffle(options);
        currentQ.currentOptions = options;

        // Broadcast Options
        broadcast({ type: 'START_VOTE', options: options.map(o => o.text) });

        // Host Display setup
        document.getElementById('vote-q-text').innerText = currentQ.q;
        document.getElementById('vote-done-count').innerText = "0";
        document.getElementById('voting-status-msg').classList.remove('hidden');
        document.getElementById('btn-show-result').classList.add('hidden');
        
        renderHostVoteOptions(); // Display options without votes initially
        
        showScreen('host-vote-phase');
    }

    function renderHostVoteOptions(showVotes = false) {
        const options = currentQ.currentOptions;
        const list = document.getElementById('options-display');
        list.innerHTML = options.map((o, i) => {
            let voteTags = "";
            if (showVotes) {
                // Find who voted for this index
                Object.keys(players).forEach(pid => {
                    if (parseInt(players[pid].vote) === i) {
                        voteTags += `<span class="voter-tag">${players[pid].name}</span>`;
                    }
                });
            }
            return `<li class="opt-row">${i+1}. ${o.text} ${voteTags}</li>`;
        }).join('');
    }

    function checkAllVotesReceived() {
        const pIds = Object.keys(players);
        const done = pIds.filter(pid => players[pid].vote !== '').length;
        document.getElementById('vote-done-count').innerText = done;

        if (done === pIds.length) {
            // 全員投票完了！
            document.getElementById('voting-status-msg').classList.add('hidden');
            document.getElementById('btn-show-result').classList.remove('hidden');
            
            // 誰がどこに投票したかを表示
            renderHostVoteOptions(true);
        }
    }

    function calcResults() {
        const options = currentQ.currentOptions;
        let detailLog = "";

        // Scoring Logic
        Object.keys(players).forEach(pid => {
            const p = players[pid];
            const votedIndex = parseInt(p.vote);
            const votedOption = options[votedIndex];
            
            if (votedOption.owner === 'SYSTEM') {
                p.score += 1;
            } else {
                if (votedOption.owner !== pid) {
                    const liarId = votedOption.owner;
                    if(players[liarId]) {
                        players[liarId].score += 1;
                    }
                }
            }
        });

        // Create Option Details List (Who made what + Who voted what)
        options.forEach((opt, i) => {
            let authorName = "";
            let liClass = "";
            
            if (opt.owner === 'SYSTEM') {
                authorName = "★正解";
                liClass = "real-answer-box";
            } else {
                authorName = players[opt.owner] ? `作者: ${players[opt.owner].name}` : "Unknown";
            }

            // Voters for this option
            let voters = [];
            Object.keys(players).forEach(pid => {
                if (parseInt(players[pid].vote) === i) voters.push(players[pid].name);
            });
            let votersText = voters.length > 0 ? `→ 投票: ${voters.join(', ')}` : "";

            detailLog += `<li class="${liClass}">
                <div style="font-size:18px; font-weight:bold;">${opt.text}</div>
                <div class="author-tag">${authorName} ${votersText}</div>
            </li>`;
        });

        // Display
        document.getElementById('real-answer-display').innerText = `正解: ${currentQ.a}`;
        document.getElementById('options-detail-list').innerHTML = detailLog;
        
        updatePlayerList(); 
        
        const totalLog = Object.values(players).sort((a,b)=>b.score - a.score).map(p => 
            `<li class="score-box"><span>${p.name}</span> <span style="font-size:20px; font-weight:bold;">${p.score}pt</span></li>`
        ).join('');
        document.getElementById('total-scores').innerHTML = `<ul>${totalLog}</ul>`;

        broadcast({ type: 'SHOW_RESULT' });
        showScreen('host-result');
    }

    function backToLobby() {
        showScreen('host-lobby');
        broadcast({ type: 'BACK_TO_LOBBY' });
    }

    // ================= CLIENT LOGIC =================

    function initClient(hostId) {
        showScreen('client-login');
        peer = new Peer();
        peer.on('open', (id) => {
            myId = id;
            hostConn = peer.connect(hostId);
            hostConn.on('open', () => { console.log("Connected"); });
            hostConn.on('data', (data) => { handleClientData(data); });
        });
    }

    function joinGame() {
        const name = document.getElementById('my-name').value;
        if (!name) return alert("名前を入力してください");
        hostConn.send({ type: 'JOIN', name: name });
        showScreen('client-wait');
    }

    function handleClientData(data) {
        if (data.type === 'START_INPUT') {
            document.getElementById('cli-q-text').innerText = data.q;
            document.getElementById('fake-answer').value = "";
            showScreen('client-input');
        } else if (data.type === 'START_VOTE') {
            renderClientOptions(data.options);
            showScreen('client-vote');
        } else if (data.type === 'SHOW_RESULT') {
            document.getElementById('cli-result-msg').innerText = "親画面で結果を確認してください！";
            showScreen('client-result');
        } else if (data.type === 'BACK_TO_LOBBY') {
            showScreen('client-wait');
        }
    }

    function submitFakeAnswer() {
        const ans = document.getElementById('fake-answer').value;
        if (!ans) return;
        hostConn.send({ type: 'FAKE_ANSWER', answer: ans });
        document.getElementById('client-input').innerHTML = "<h2>送信完了！</h2><p>他の人を待っています...</p>";
    }

    function renderClientOptions(options) {
        const container = document.getElementById('cli-options');
        container.innerHTML = options.map((opt, i) => 
            `<button class="btn-opt" onclick="submitVote(${i})">${opt}</button>`
        ).join('');
    }

    function submitVote(index) {
        hostConn.send({ type: 'VOTE', vote: index });
        document.getElementById('client-vote').innerHTML = "<h2>投票完了！</h2><p>集計中...</p>";
    }

    // ================= UTILS =================

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }

    function broadcast(data) {
        Object.values(connections).forEach(conn => conn.send(data));
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

</script>
</body>
</html>
